const express = require('express');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const bodyParser = require('body-parser');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const authRoutes = require('./routes/auth');
const messageRoutes = require('./routes/messages');
const Message = require('./models/Message');
const Channel = require('./models/Channel');  // Importation du mod√®le de canal
const User = require('./models/User'); // Ajout de l'import User

dotenv.config();

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: 'http://localhost:3000',
    methods: ['GET', 'POST'],
  },
});

const PORT = process.env.PORT || 5000;

// Map pour associer les socket IDs aux user IDs
const userSocketMap = new Map();

// ‚úÖ Middleware
app.use(express.json()); // Important pour traiter correctement les JSON
app.use(bodyParser.json()); // Redondant mais ajout√© au cas o√π
app.use(cors());

// ‚úÖ Connexion √† MongoDB
mongoose.connect('mongodb://localhost:27017/irc', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log('Connect√© √† MongoDB'))
.catch((err) => console.error('Erreur de connexion √† MongoDB:', err));

// ‚úÖ V√©rification du bon chargement des routes
app.use('/api/auth', authRoutes);
app.use('/api/messages', messageRoutes);

app.get('/', (req, res) => {
  res.send('‚úÖ Serveur en ligne avec Socket.IO et MongoDB');
});

// üìå Route pour cr√©er un canal
app.post('/api/channels', async (req, res) => {
  const { name, creator } = req.body;  // Le nom du canal et le cr√©ateur doivent √™tre fournis dans la requ√™te

  if (!name || !creator) {
    return res.status(400).json({ message: 'Le nom du canal et le cr√©ateur sont n√©cessaires.' });
  }

  try {
    // V√©rification si un canal avec ce nom existe d√©j√†
    const existingChannel = await Channel.findOne({ name });
    if (existingChannel) {
      console.log('Tentative de cr√©ation d\'un channel d√©j√† existant:', name);
      return res.status(400).json({ message: 'Un canal avec ce nom existe d√©j√†.' });
    }

    // Cr√©ation d'un nouveau canal
    const newChannel = new Channel({
      name,
      creator,
    });

    await newChannel.save();  // Sauvegarde du canal dans la base de donn√©es

    res.status(201).json(newChannel);  // Retourne les informations du canal cr√©√©
  } catch (error) {
    console.error('Erreur lors de la cr√©ation du canal:', error);
    res.status(500).json({ message: 'Erreur serveur', error: error.message });
  }
});

// === ROUTES REST SUPPL√âMENTAIRES ===

// Lister tous les channels (option de filtre par nom, ou tous si all=1)
app.get('/api/channels', async (req, res) => {
  const { name, all, userId } = req.query;
  try {
    let query = {};
    if (name) query.name = { $regex: name, $options: 'i' };
    if (!all && userId) {
      // Ne retourne que les channels o√π l'utilisateur est membre ou cr√©ateur
      const user = await User.findById(userId);
      if (!user) return res.status(401).json({ message: 'Utilisateur non trouv√©.' });
      query.$or = [
        { _id: { $in: user.channels } },
        { creator: user.username }
      ];
    }
    const channels = await Channel.find(query);
    res.status(200).json(channels);
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur.' });
  }
});

// Rejoindre un channel
app.post('/api/channels/join', async (req, res) => {
  const { userId, channelId } = req.body;
  if (!userId || !channelId) return res.status(400).json({ message: 'userId et channelId requis.' });
  try {
    const user = await User.findById(userId);
    const channel = await Channel.findById(channelId);
    if (!user || !channel) return res.status(404).json({ message: 'User ou Channel non trouv√©.' });
    // Ajoute le user au channel si pas d√©j√† pr√©sent
    if (!channel.users.includes(user.username)) {
      channel.users.push(user.username);
      await channel.save();
    }
    // Ajoute le channel au user si pas d√©j√† pr√©sent
    if (!user.channels.includes(channel._id)) {
      user.channels.push(channel._id);
      await user.save();
    }
    res.status(200).json({ message: 'Channel rejoint.' });
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur.' });
  }
});

// Quitter un channel
app.post('/api/channels/quit', async (req, res) => {
  const { userId, channelId } = req.body;
  if (!userId || !channelId) return res.status(400).json({ message: 'userId et channelId requis.' });
  try {
    const user = await User.findById(userId);
    const channel = await Channel.findById(channelId);
    if (!user || !channel) return res.status(404).json({ message: 'User ou Channel non trouv√©.' });
    // Retire le user du channel
    channel.users = channel.users.filter(u => u !== user.username);
    await channel.save();
    // Retire le channel du user
    user.channels = user.channels.filter(cid => cid.toString() !== channel._id.toString());
    await user.save();
    res.status(200).json({ message: 'Channel quitt√©.' });
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur.' });
  }
});

// Lister les utilisateurs d'un channel
app.get('/api/channels/:id/users', async (req, res) => {
  try {
    const channel = await Channel.findById(req.params.id);
    if (!channel) return res.status(404).json({ message: 'Channel non trouv√©.' });
    res.status(200).json(channel.users);
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur.' });
  }
});

// Supprimer un channel (par son cr√©ateur)
app.delete('/api/channels', async (req, res) => {
  const { name } = req.body;
  const token = req.headers.authorization?.split(' ')[1];
  if (!name || !token) return res.status(400).json({ message: 'Nom du canal et token requis.' });
  try {
    const decoded = require('jsonwebtoken').verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id);
    if (!user) return res.status(401).json({ message: 'Utilisateur non trouv√©.' });
    const channel = await Channel.findOne({ name });
    if (!channel) return res.status(404).json({ message: 'Canal non trouv√©.' });
    if (channel.creator !== user.username) return res.status(403).json({ message: 'Seul le cr√©ateur peut supprimer ce canal.' });
    await channel.deleteOne();
    res.status(200).json({ message: 'Canal supprim√©.' });
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur.' });
  }
});

// üìå Gestion des messages en temps r√©el avec Socket.IO
io.on('connection', (socket) => {
  console.log(`üîå Utilisateur connect√© : ${socket.id}`);
  socket.joinedChannels = new Set();

  // Associe le socket √† l'userId √† la connexion (re√ßu du client)
  socket.on('registerUser', (userId) => {
    if (userId) userSocketMap.set(socket.id, userId);
  });

  // Rejoindre un channel (room)
  socket.on('joinChannel', async ({ userId, channelId }) => {
    try {
      const user = await User.findById(userId);
      const channel = await Channel.findById(channelId);
      if (!user || !channel) return;
      
      // V√©rifie si l'utilisateur √©tait d√©j√† dans le channel
      let wasAlreadyIn = channel.users.includes(user.username);
      
      // Ajoute le user au channel si pas d√©j√† pr√©sent
      if (!wasAlreadyIn) {
        await Channel.findByIdAndUpdate(channelId, {
          $addToSet: { users: user.username }
        });
      }
      if (!user.channels.includes(channel._id)) {
        await User.findByIdAndUpdate(userId, {
          $addToSet: { channels: channel._id }
        });
      }
      
      // Rejoint la room Socket.IO
      socket.join(channelId);
      socket.joinedChannels.add(channelId);
      
      // Message syst√®me : user a rejoint (uniquement si ce n'est pas un refresh)
      if (!wasAlreadyIn) {
        const systemMsg = new Message({
          username: 'SYSTEM',
          text: `${user.username} a rejoint le channel.`,
          channel: channelId,
          createdAt: new Date(),
        });
        await systemMsg.save();
        
        // Envoyer le message syst√®me √† tous les utilisateurs connect√©s dans ce channel
        const usersInChannel = await User.find({ channels: channelId });
        console.log(`[SYSTEM] Envoi du message de join √† ${usersInChannel.length} utilisateurs dans le channel ${channel.name}`);
        
        // Envoyer le message √† tous les utilisateurs connect√©s dans ce channel
        for (const userInChannel of usersInChannel) {
          const userSocketIds = Array.from(userSocketMap.entries())
            .filter(([_, userId]) => userId === userInChannel._id.toString())
            .map(([socketId, _]) => socketId);
          
          for (const socketId of userSocketIds) {
            io.to(socketId).emit('systemMessage', systemMsg);
            console.log(`[SYSTEM] Message envoy√© √† ${userInChannel.username} (socket: ${socketId})`);
          }
        }
        
        console.log(`${user.username} a rejoint le channel ${channel.name}`);
      }
    } catch (err) {
      console.error('Erreur joinChannel:', err);
    }
  });

  // Quitter un channel (room)
  socket.on('quitChannel', async ({ userId, channelId }) => {
    try {
      const user = await User.findById(userId);
      const channel = await Channel.findById(channelId);
      if (!user || !channel) return;
      
      // V√©rifie si l'utilisateur √©tait dans le channel AVANT de le retirer
      const wasIn = channel.users.includes(user.username);
      
      // Message syst√®me : user a quitt√© (uniquement si l'utilisateur √©tait dans le channel)
      if (wasIn) {
        const systemMsg = new Message({
          username: 'SYSTEM',
          text: `${user.username} a quitt√© le channel.`,
          channel: channelId,
          createdAt: new Date(),
        });
        await systemMsg.save();
        
        // Envoyer le message syst√®me √† tous les utilisateurs connect√©s dans ce channel
        // (AVANT de retirer l'utilisateur du channel)
        const usersInChannel = await User.find({ channels: channelId });
        console.log(`[SYSTEM] Envoi du message de quit √† ${usersInChannel.length} utilisateurs dans le channel ${channel.name}`);
        
        for (const userInChannel of usersInChannel) {
          const userSocketIds = Array.from(userSocketMap.entries())
            .filter(([_, userId]) => userId === userInChannel._id.toString())
            .map(([socketId, _]) => socketId);
          
          for (const socketId of userSocketIds) {
            io.to(socketId).emit('systemMessage', systemMsg);
            console.log(`[SYSTEM] Message envoy√© √† ${userInChannel.username} (socket: ${socketId})`);
          }
        }
        
        console.log(`${user.username} a quitt√© le channel ${channel.name}`);
      }
      
      // Maintenant on retire l'utilisateur du channel
      socket.leave(channelId);
      socket.joinedChannels.delete(channelId);
      await Channel.findByIdAndUpdate(channelId, {
        $pull: { users: user.username }
      });
      // Retire le channel du user
      await User.findByIdAndUpdate(userId, {
        $pull: { channels: channel._id }
      });
    } catch (err) {
      console.error('Erreur quitChannel:', err);
    }
  });

  // Envoyer un message √† un channel
  socket.on('sendMessage', async ({ userId, username, channelId, text }) => {
    if (!userId || !username || !channelId || !text.trim()) {
      socket.emit('error', 'Donn√©es invalides.');
      return;
    }
    try {
      const newMessage = new Message({
        userId,
        username,
        text: text.trim(),
        channel: channelId,
        createdAt: new Date(),
      });
      await newMessage.save();
      io.to(channelId).emit('newMessage', newMessage);
      console.log(`Message envoy√© dans le channel ${channelId} par ${username}`);
    } catch (err) {
      console.error('Erreur sendMessage:', err);
      socket.emit('error', 'Erreur lors de l‚Äôenvoi du message.');
    }
  });



  // Envoyer un message priv√© (par username)
  socket.on('sendPrivateMessage', async ({ userId, username, toUsername, text }) => {
    if (!userId || !username || !toUsername || !text.trim()) {
      socket.emit('error', 'Donn√©es invalides.');
      return;
    }
    try {
      const toUser = await User.findOne({ username: toUsername });
      if (!toUser) {
        socket.emit('error', 'Destinataire non trouv√©.');
        return;
      }
      const newMessage = new Message({
        userId,
        username,
        text: text.trim(),
        to: toUser._id,
        toUsername: toUsername,
        createdAt: new Date(),
      });
      await newMessage.save();
      
      // Cr√©er un message pour l'exp√©diteur (avec toUsername)
      const senderMessage = {
        ...newMessage.toObject(),
        toUsername: toUsername
      };
      
      // Cr√©er un message pour le destinataire (avec username de l'exp√©diteur)
      const receiverMessage = {
        ...newMessage.toObject(),
        toUsername: username
      };
      
      // Envoie le message √† l'exp√©diteur
      io.to(socket.id).emit('privateMessage', senderMessage);
      
      // Envoie le message au destinataire si connect√©
      const destSocketIds = Array.from(userSocketMap.entries())
        .filter(([_, userId]) => userId === toUser._id.toString())
        .map(([socketId, _]) => socketId);
      destSocketIds.forEach(socketId => {
        io.to(socketId).emit('privateMessage', receiverMessage);
      });
      console.log(`Message priv√© de ${username} √† ${toUsername}`);
    } catch (err) {
      console.error('Erreur sendPrivateMessage:', err);
      socket.emit('error', 'Erreur lors de l‚Äôenvoi du message priv√©.');
    }
  });

  // Charger l'historique des messages d'un channel
  socket.on('fetchChannelMessages', async (channelId) => {
    try {
      const messages = await Message.find({ channel: channelId }).sort({ createdAt: 1 });
      socket.emit('loadChannelMessages', messages);
    } catch (err) {
      socket.emit('error', 'Erreur lors du chargement des messages du channel.');
    }
  });

  // Charger l'historique des messages priv√©s
  socket.on('fetchPrivateMessages', async ({ userId, toUserId }) => {
    try {
      const messages = await Message.find({
        $or: [
          { userId, to: toUserId },
          { userId: toUserId, to: userId },
        ],
      }).sort({ createdAt: 1 });
      socket.emit('loadPrivateMessages', messages);
    } catch (err) {
      socket.emit('error', 'Erreur lors du chargement des messages priv√©s.');
    }
  });

  // Nettoie le mapping √† la d√©connexion
  socket.on('disconnect', () => {
    userSocketMap.delete(socket.id);
    console.log(`‚ùå Utilisateur d√©connect√© : ${socket.id}`);
  });
});

// ‚úÖ D√©marrage du serveur
server.listen(PORT, () => {
  console.log(`üöÄ Serveur d√©marr√© sur http://localhost:${PORT}`);
});
